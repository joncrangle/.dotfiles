#!/usr/bin/env zsh
# NOTE:
#   (`-')   (`-').-> (`-').->
#   ( OO).->( OO)_   (OO )__
# ,(_/----.(_)--\_) ,--. ,'-'
# |__,    |/    _ / |  | |  |
#  (_/   / \_..`--. |  `-'  |
#  .'  .'_ .-._)   \|  .-.  |
# |       |\       /|  | |  |
# `-------' `-----' `--' `--'
# ##############################
# #         ZSH ALIASES        #
# ##############################

########## Core / Safe Aliases ##########
alias c="clear"
alias reload='exec zsh -l'
alias x="exit"
alias wget="wget -c"

# Set editors
alias v="${EDITOR:-vim}"
alias vi="${EDITOR:-vim}"
alias vim="${EDITOR:-vim}"

########## Conditional "Hijacks" ##########

_is_installed() {
	command -v "$1" >/dev/null 2>&1
}

# Bat (replacing cat)
if _is_installed bat; then
	alias cat="bat"
fi

# Zoxide (replacing cd)
# Checks for 'z' command or function (since zoxide often loads as a function)
if _is_installed zoxide || type z &>/dev/null; then
	alias cd="z"
fi

# Chezmoi
if _is_installed chezmoi; then
	alias cm="chezmoi"
	alias cme="cd $HOME/.config/.local/share/chezmoi"
	alias cmu="chezmoi update && chezmoi apply"
fi

# Podman
if _is_installed podman; then
	alias dock="podman compose pull && podman compose up -d; podman system prune -a -f"
fi

# Git / LazyGit
# '-s' suffix alias means typing 'directory.git' will run 'git clone directory.git'
alias -s git="git clone"

if _is_installed lazygit; then
	alias lazy="lazygit"
	alias lg="lazygit"
	alias lzg="lazygit"
fi

# LazyDocker
if _is_installed lazydocker; then
	{{ if eq .chezmoi.os "linux" }}
	alias lazydocker='DOCKER_HOST=unix:///run/user/1000/podman/podman.sock lazydocker'
	{{ else }}
	alias lazydocker='DOCKER_HOST=unix:///var/folders/73/jfd1wwgs4vq7hfw79_2fdcm00000gn/T/podman/podman-machine-default-api.sock lazydocker'
	{{ end }}
	alias lzd="lazydocker"
fi

# Eza (replacing ls and tree)
if _is_installed eza; then
	alias ls="eza"
	alias l="eza --icons"
	alias ll="eza -l --icons"
	alias la="eza -la --icons"
	alias tree="eza -T --icons --level=2"
fi

# OpenCode
if _is_installed opencode; then
	alias oc="opencode --port --agent orchestrator"
fi

# Podapple
if _is_installed podapple; then
	alias pod="podapple"
fi

# UV (replacing python)
if _is_installed uv; then
	alias python="uv run"
	alias python3="uv run"
fi

# Topgrade
if _is_installed topgrade; then
	alias tg='topgrade'
fi

# Btop (replacing top)
if _is_installed btop; then
	alias top="btop"
fi

alias refresh-completions="~/.config/zsh/update_completions.zsh"

########## Functions ##########

brew-upgrade() {
	brew upgrade --cask wezterm@nightly --no-quarantine --greedy-latest
	brew update
	brew upgrade
	brew cleanup
}

def() {
	local raw_json=$(curl -s "https://api.dictionaryapi.dev/api/v2/entries/en/$1")

	if echo "$raw_json" | jq -e 'if type == "object" then .title else false end' >/dev/null; then
		echo -e "\n  \033[1;31m× Word not found.\033[0m\n"
		return
	fi

	echo -e "\n  \033[1;34m$(echo $raw_json | jq -r '.[0].word | ascii_upcase')\033[0m  $(echo $raw_json | jq -r '.[0].phonetic // ""')"
	echo -e "  \033[0;34m───────────────────────────────────\033[0m"

	echo "$raw_json" | jq -r '.[0].meanings[] | "\n  \u001b[1;33m\(.partOfSpeech)\u001b[0m", (.definitions[] | "  • \(.definition)")'
	echo ""
}

extract() {
	if [ -f $1 ]; then
		case $1 in
		*.tar.bz2) tar xvjf $1 ;;
		*.tar.gz) tar xvzf $1 ;;
		*.tar.xz) tar xvf $1 ;;
		*.bz2) bunzip2 $1 ;;
		*.rar) unrar x $1 ;;
		*.gz) gunzip $1 ;;
		*.tar) tar xvf $1 ;;
		*.tbz2) tar xvjf $1 ;;
		*.tgz) tar xvzf $1 ;;
		*.zip) unzip $1 ;;
		*.Z) uncompress $1 ;;
		*.7z) 7z x $1 ;;
		*) echo "don't know how to extract '$1'..." ;;
		esac
	else
		echo "'$1' is not a valid file!"
	fi
}

extract-audio-and-video() {
	ffmpeg -i "$1" -c:a copy audio.aac
	ffmpeg -i "$1" -c:v copy video.mp4
}

git-backup() {
	if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
		gum style --foreground 196 --bold "✖ Error: You are not inside a Git repository."
		return 1
	fi

	if ! command -v gum &>/dev/null; then
		echo "Error: 'gum' is not installed. Install with 'brew install gum'"
		return 1
	fi

	local default_name=$(basename "$(git rev-parse --show-toplevel)")
	local current_origin=$(git remote get-url origin 2>/dev/null)

	if [ -z "$current_origin" ]; then
		gum style --foreground 196 "✖ Error: Remote 'origin' not found. Add a GitHub remote first."
		return 1
	fi

	gum style --foreground 212 "Forgejo Backup Configurator"
	local repo_name=$(gum input --placeholder "Enter repository name" --value "$default_name")

	# Exit if user cancels (Esc/Ctrl+C)
	[ -z "$repo_name" ] && return

	gum spin --spinner dot --title "Configuring remotes..." -- sleep 0.5
	git remote set-url --push origin "$current_origin"
	git remote set-url --add --push origin "forgejo:jon/${repo_name}.git"

	gum style --foreground 10 "✅ Success! Remote 'origin' now pushes to both."
	git remote -v | gum format
}

git-tag() {
	local version=""
	local message=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
		-v | --version)
			shift
			version="$1"
			;;
		-m | --message)
			shift
			message="$1"
			;;
		*)
			echo "Invalid option: $1"
			echo "Usage: git-tag -v <version> -m <message>"
			return 1
			;;
		esac
		shift
	done

	# Check if version and message are provided
	if [ -z "$version" ] || [ -z "$message" ]; then
		echo "Usage: git-tag -v <version> -m <message>"
		return 1
	fi

	git tag -a "$version" -m "$message"
	git push origin "$version"
}

pass() {
	echo "Generate password"
	LENGTH=32
	CHOICE=$(gum choose "short (12)" "medium (20)" "long (32)" "custom")

	case "$CHOICE" in
	short*)
		LENGTH=12
		;;
	medium*)
		LENGTH=20
		;;
	long*)
		LENGTH=32
		;;
	custom)
		LENGTH=$(gum input --placeholder "Enter custom length")
		;;
	esac

	PASSWORD=$(openssl rand -base64 "$LENGTH")

	if command -v pbcopy >/dev/null; then
		echo -n "$PASSWORD" | pbcopy
		echo -e "$PASSWORD\nCopied to clipboard"
	elif command -v wl-copy >/dev/null; then
		echo -n "$PASSWORD" | wl-copy
		echo -e "$PASSWORD\nCopied to clipboard"
	else
		echo "pbcopy or wl-copy command not found. Unable to copy to clipboard."
	fi
}

# Interactive Port Killer
prip() {
	local sig selection pids
	sig="${1:-15}"

	if command -v ss >/dev/null 2>&1; then
		# Linux: Port(1) Process(2) PID(3)
		selection=$(ss -tulpn | grep LISTEN | awk '{split($7,a,","); print $5, a[1], a[2]}' | sed 's/.*:\([0-9]*\)/\1/; s/users:(("//; s/pid=//' | sk \
			--multi \
			--ansi \
			--layout=reverse \
			--nth=1,2 \
			--header="[Port-Kill: ss] Search: Port or Process" \
			--preview "echo {3} | xargs -I{} ps -p {} -o pid,ppid,user,stat,start,time,command" \
			--preview-window="down:40%")

		pids=$(echo "$selection" | awk '{print $3}' | sort -u)
	else
		# macOS: Port(1) Process(2) PID(3)
		selection=$(lsof -iTCP -sTCP:LISTEN -P -n | awk 'NR>1 {print $9, $1, $2}' | sed 's/.*://' | sk \
			--multi \
			--ansi \
			--layout=reverse \
			--nth=1,2 \
			--header="[Port-Kill: lsof] Search: Port or Process" \
			--preview "ps -p {3} -o pid,ppid,user,stat,start,time,command" \
			--preview-window="down:40%")

		pids=$(echo "$selection" | awk '{print $3}' | sort -u)
	fi

	[[ -z "$pids" ]] && return

	echo "Killing PID(s): $pids"
	echo "$pids" | xargs kill -"$sig"
}

# Interactive Process Killer
rip() {
	local sig pids
	sig="${1:-15}"

	pids=$(sk -i -c "ps -Ao pid,comm | grep -i '{q}'" \
		--ansi \
		--multi \
		--layout=reverse \
		--delimiter='[[:space:]]+' \
		--nth=2 \
		--tiebreak=begin,length \
		--header="[Kill] SIG$sig | Enter: Kill | Query: {q}" \
		--preview "ps -p {1} -o pid,ppid,user,stat,start,time,command" \
		--preview-window="down:40%" |
		awk '{print $1}')

	[[ -z "$pids" ]] && return

	echo "Killing with SIG$sig: $pids"
	echo "$pids" | xargs kill -"$sig"
}

# Sudo intercept for editors to use sudoedit instead
sudo() {
	if [[ "$1" == "nvim" || "$1" == "v" || "$1" == "vim" ]]; then
		shift
		# Just use the variable you already defined
		command sudoedit "$@"
	else
		command sudo "$@"
	fi
}

take() {
	mkdir -p $1
	cd $1
}

# Interactive search and open-at-line/copy-line
vs() {
	local cp="pbcopy"
	command -v wl-copy >/dev/null && cp="wl-copy"

	# Run Skim in Interactive Mode
	# --nth 3..: Only score/match the actual code content
	# --bind: Ctrl-Y copies and aborts (closes sk)
	# Enter: Prints the line and exits sk (allowing nvim to take over)
	local selected
	selected=$(sk --ansi -i -c "rg --color=always --line-number --no-heading --smart-case {q} || true" \
		--delimiter ':' \
		--nth '3..' \
		--tiebreak 'begin,length' \
		--layout 'reverse' \
		--header "[Grep] Enter: Open at Line | Ctrl-Y: Copy Text" \
		--preview 'bat --color=always --style=numbers --highlight-line {2} {1}' \
		--preview-window 'up:60%:wrap:+{2}-/2' \
		--bind "ctrl-y:execute-silent(echo {3..} | sed 's/^[[:space:]]*//' | $cp)+abort")

	# If we aborted (Ctrl-Y or Esc), exit the function
	[[ -z "$selected" ]] && return

	# Parse fields and launch Editor
	local file="${selected%%:*}"
	local rest="${selected#*:}"
	local line="${rest%%:*}"

	command nvim "$file" "+$line"
}

function yy() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		cd "$cwd"
	fi
	rm -f -- "$tmp"
}
# vim: ft=zsh
